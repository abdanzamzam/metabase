(ns src.dev.add-load
  (:require [clojure.walk :as walk]
            [dev.with-perm :as perm]
            [metabase.test :as mt]
            [metabase.util.malli :as mu]))

(def ^:private logical-kw
  "A keyword that starts with a question mark, used to track values created by from-script."
  [:and :keyword [:fn #(= "?" (namespace %))]])

(mu/defn- extract-bindings
  "Extracts the bindings from the script and inserts the values into the ids map. This is the data oriented equivalent
  of let."
  [bindings :- [:or :map logical-kw] inserted]
  (cond (map? bindings)
        (update-vals bindings #(get inserted %))
        (and (keyword? bindings) (= "?" (namespace bindings)))
        {bindings inserted}))

(mu/defn- fill-attrs
  "Data oriented value resolution used to add attributes to a model from the [[attrs]] map."
  [ids :- :map attrs :- :map step]
  (walk/postwalk
   (fn [x] (if-let
               [value (get ids x)]
             value
             (do (when (and (keyword? x) (= "?" (namespace x)))
                   (throw (ex-info (str "Problem in script, unbound value: " x) {:step step})))
                 x)))
   attrs))

(def ^:private BindingForm [:or [:= :?] logical-kw :map])
(def ^:private NormalizedTuple [:tuple :keyword BindingForm :map])

(def Tuple [:or [:tuple :keyword] [:tuple :keyword BindingForm] NormalizedTuple])

(mu/defn normalize-tuple :- NormalizedTuple
  [next-kw-thunk :- fn? t :- Tuple]
  (let [[model bindings attrs] t]
    [model
     (if (or (nil? bindings) (= :? bindings)) (next-kw-thunk) bindings)
     (or attrs {})]))

(mu/defn from-script*
  "Takes a script and inserts the entities into the database. Returns a map of the ids of the entities inserted.

  The script is similar to the one used by [[mt/with-temp]], but instead of code to be executed, it contains the
  entities to be inserted, and values to be bound _as data_. The entities are inserted in the order they appear in the
  script, and their bound values are saved in a map."
  [script :- [:sequential Tuple]]
  (let [ids (atom {})]
    (doseq [[modelable bindings attrs :as step] script]
      (let [to-put (fill-attrs @ids attrs step)
            _ (prn [:TO_PUT to-put])
            inserted (perm/with-perm modelable to-put)]
        (swap! ids merge (extract-bindings bindings inserted))
        inserted))
    (update-keys @ids (comp keyword name))))

(defn- make-next-kw-thunk []
  (let [kw-idx (atom 0)]
    (fn [] (keyword "?" (str "_" (swap! kw-idx inc))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; PUBLIC API ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(mu/defn from-script :- :map
  "Takes a script and inserts the entities into the database. Returns a map of the ids of the entities inserted."
  [script :- [:sequential Tuple]]
  (->>
   script
   (mapv (partial normalize-tuple (make-next-kw-thunk)))
   ;; TODO build a dag and insert in topological order, batched
   ;; NOTE check what normalized-tuples are like so:
   ;; ((fn [x] (def normalized-tuples x) x))
   from-script*))

;; # From-Script
;;
;; This is a data-oriented version of `with-temp`. Instead of executing code, it inserts entities into the database.
;; The script is similar to the one used by `mt/with-temp`, but instead of code to be executed, it contains the entities
;; to be inserted, and values to be bound _as data_. The entities are inserted in the order they appear in the script, and
;; their bound values can be saved in a map (or ignored).
;;
;; # Compared to with `with-temp`:
;;
;; ## `with-temp`:
;; - Data looks like: [:model/Card {card-id :id} {:name "My Card 1"}]
;;
;; - Uses `t2.with-temp/with-temp-defaults` to fill in entity attributes.
;;
;; - Inside body, can access card-id, and the card is deleted after the body.
;;
;; ## `from-script`:
;; - Data looks like: [[:model/Card {:?/card-id :id} {:name "My Card 1"}]]
;;
;; - Uses `t2.with-temp/with-temp-defaults` to fill in entity attributes.
;;
;; There is no body, so calling `from-script` will persist the data, and return info about the inserted entities.
;; (from-script [[:model/Card {:?/card-id :id} {:name "My Card 1"}]])
;; ;; => {:card-id 552}
;;
;; ## Value Tracking
;; How do we track what got inserted? Sometimes we don't care, but sometimes we do. That's next:
;;
;; # Getting values back from the script:
;;
;; There are 3 ways to get info back:
;;
;; 1. `:?` as the binding form. Then you'll get an autogenerated key returned:
;; ;; (from-script [[:model/Card :? {}]])
;; ;; => {:_1 <card instance>}
;;
;; 2. Keywords like `:?/my-card` as the binding form, where the key returned will be `:my-card`.
;; ;; (from-script [[:model/Card :?/my-card {}]])
;; ;; => {:my-card <card instance>}
;;
;; 3. Maps that look like map destructuring with logical keywords (e.g. `:?/a`), and the values will be bound:
;; ;; (from-script [[:model/Card {:?/my-card-id :id} {}]])
;; ;; => {:my-card-id 3993}
;;
;; # Actual examples
;;
;; 3-tuples in the script can refer to earlier ones (just like `with-temp`!):
;;
;; ;; 1 collection with 50 cards
;; (from-script
;;  (into [[:model/Collection {:?/collection-id :id} {}]
;;         [:model/User {:?/user-id :id} {}]]
;;        (repeat 50 [:model/Card {} {:collection_id :?/collection-id :creator_id :?/user-id}])))
;; ;; => {:collection-id 300, :user-id 8}
;;
;; ;; Let's do 80 users in 40 perm groups
;; (->> (mapcat
;;       (fn [idx]
;;         [[:model/PermissionsGroup {(keyword "?" (str "group_" idx)) :id} {}]
;;          [:model/User {} {:first_name (str "a_" idx)}]
;;          [:model/User {} {:first_name (str "b_" idx)}]])
;;       (range 1 41)) ;; <- eval here
;;      from-script keys sort vec)
;; ;; => [:_1 .. :_9 :group_1 .. :group_9]
;;
;; ;; Imagine ur doing search and want good perf, so you want e.g. N cards, M dashboards, strongly linked together:
;; ;; Since we can reuse ids from previous steps:
;;
;; (defn strongly-connected-cards-and-dashboards [card-count dash-count]
;;   (let [cards (mapv (fn [i] [:model/Card {(keyword "?" (str "card_" i)) :id} {:name (str "Card " i)
;;                                                                               :type          :question
;;                                                                               ;; I hope we can get away from this state leaking in:
;;                                                                               :dataset_query (mt/mbql-query users)}])
;;                     (range 1 (inc card-count)))
;;         dashboards (mapv (fn [i] [:model/Dashboard {(keyword "?" (str "dash_" i)) :id} {:name (str "Dashboard" i)}])
;;                          (range 1 (inc dash-count)))
;;         dashcards (for [[_ c _] cards
;;                         [_ d _] dashboards
;;                         :let [card-id (first (keys c))]
;;                         :let [dash-id (first (keys d))]]
;;                     [:model/DashboardCard {} {:card_id card-id :dashboard_id dash-id :size_x 12 :size_y 6}])]
;;     (concat cards dashboards dashcards)))
;;
;; This inserts 10200 entities in about 8 seconds:
;; (time (from-script (strongly-connected-cards-and-dashboards 100 100)))
;;
;; # CheatSheet:
;;
;; One random card but give it a name
;; (add-load/from-script [[:model/Card :? {:name "My Card 1"}]])
;;
;; Ignore the return value, pass empty map as binding form
;; (add-load/from-script [[:model/Card {} {:name "My Card 5"}]])
;;
;; One random card, given the key :my-card
;; (from-script [[:model/Card :?/my-card {:name "My Card 2"}]])
;; => {:my-card <card instance>}
;;
;; Desctructure card id
;; (add-load/from-script [[:model/Card {:?/card-id :id} {:name "My Card 4"}]])
;; => {:card-id 559}
;;
;; ## Shorthand
;; One random card:
;; (from-script [[:model/Card]])
;; ;; => {:_1 <card instance>}
;;
;; Ignore the return value:
;; (from-script [[:model/Card {}]])
;; ;; => {}
;;
;; Two random cards:
;; (from-script [[:model/Card] [:model/Card]])
;; ;; => {:_1 <card instance>, :_2 <card instance>}
